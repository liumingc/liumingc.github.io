---
layout: post
title:  "Poly build instructions"
date:   2019-02-15 01:37:50 +0800
categories: jekyll update
---

## Update(2019/05/03)

This post is updated incrementaly, and now it's in a messive state. I have to
rewrite it later. For now, it's used to record some raw notes.

## Build instruction

According to official site's instruction, you have to run
the following instructions:
```bash
make
make compiler
```

What it really does, is:
```bash
# build polyimport from C source ...
gcc ...
# to build basis lib etc
./polyimport polytemp.txt . < ./exportPoly.sml
# to build compiler
./poly --error-exit < mlsource/BuildExport.sml
# the above step will regenerate polytemp.txt, so run polyimport again
./polyimport  polytemp.txt -I . < ./exportPoly.sml
# generate poly
gcc -O3 -o poly plyexport.o libpolyxxx ...
```
polytemp.txt is generated by mlsource/BuildExport.sml, it's the portable object
file which contains the code of compiler and other stuff.
## If run PolyML.make "mlsource/MLCompiler" ...
PolyML.make is defined in basis/FinalPolyML.sml, and when it tries to compile a
structure of functor, it will try to guess a file whose name is targetName with
some suffix, in current directory. So after adding some logs, here is an example
output of compiling functor PARSE\_DEC.
```sh
+try find file=PARSE_DEC.functor.x86_64 in dir=mlsource/MLCompiler
+try find file=PARSE_DEC.functor.580 in dir=mlsource/MLCompiler
+try find file=PARSE_DEC.functor in dir=mlsource/MLCompiler
...
+try find file=PARSE_DEC.x86_64.ML in dir=mlsource/MLCompiler
+try find file=PARSE_DEC.580.ML in dir=mlsource/MLCompiler
+try find file=PARSE_DEC.ML in dir=mlsource/MLCompiler
Making PARSE_DEC
Created functor PARSE_DEC
```
And if the target to PolyML.make is a directory, then it will search a file name
ml\_bind, try some suffix, like ML or sml, then compile it. And inside
ml\_bind.ML, there are definitions for structures or functors, then follow the
previous process.

## What does exportPoly.sml do?
```sml
(* build the main basis library *)
Bootstrap.use "basis/build.sml"
PolyML.shareCommonData PolyML.rootFunction;
(* here fileName defaults to `polyexport' *)
PolyML.export(fileName, PolyML.rootFunction)
```
shareCommonData is used for reducing the image size.
The `documentation/Reference/PolyMLStructure.html#export` part has some nice
doc, saying that export will dump the rootFunction into an object file, which
is linked to build poly later.

export/exportPortable is defined in basis/InitialPolyML.ML:
```sml
val callExport: string * (unit->unit) -> unit = RunCall.rtsCallFull2
"PolyExport"
val callExportP: string * (unit->unit) -> unit = RunCall.rtsCallFull2
"PolyExportPortable"
fun export(filename, f) = callExport(filename, runFunction f)
and exportPortable(filename, f) = callExportP(filename, runFunction f)
```
I don't known what exactly happened, but, this 2 functions, is a wrapper of the
C function PolyExport and PolyExportPortable. They will append `.o`, and `.txt`
suffix to the filename. So polyimport.txt is the portable file of rootFunction,
while polyexport.o is the native file of rootFunction.
Having that idea, so polyc is just a script, which will call
PolyML.export(fileName, main) to generate the object file, then link it into an
executable binprogram.

But running nm shows that the symbol table is incomplete, but use strings to
show, there are some hidden symbols.

# Lexing
I should read `LEX_.ML`. The most important type is:
```sml
type lexan =
  {
    stream: uint -> char option,  (* get char *)
    ch: char ref,
    sy: sys ref,  (* AndSy, DatatypeSy, etc ... *)
    id: string ref,
    pushedSym: sys ref, (* to push back lookahead sy ... *)
    (* ... more fields omitted *)
  }
```
For example, `insymbol` will eat the next input symbol
```sml
fun insymbol (state as {sy, pushedSym, ...}:lexan) =
  if ! pushedSym <> OtherSy
  then
    pushedSym := OtherSy
  else
  (
    sy := OtherSy
    parseToken state
  )
```
In the firs case, `pushedSym` is not empty, which means that<br/>
there is a push back before. So we reset it, so we eat the symbol.<br/>
Otherwise, we call `parseToken` to get a new sym from the token stream.

# Parsing
Some examples of parsetree:
1. value binding
```sml
val x: int = 5;
```
is
```
ValBind ( dec=Constraint (value=Ident(x), given=int), exp=5 )
```
There is a constraint which normally will not display. And given is of type
typeParsetree.
In TYPE\_TREE.ML, we found the definition of typeParsetree:
```sml
datatype typeParsetree =
  ParseTypeConstruction of
    { name: string, args: typeParsetree list, ... }
| ParseTypeFunction of
    { argType: typeParsetree, resultType: typeParsetree, ... }
| ParseTypeProduct of
    { fields: typeParsetree list, ... }
| ParseTypeLabelled of
  { fields: (string * typeParsetree) list, frozen: bool, ... }
| ParseTypeId of { types: typeVarFrom, ... }
| ParseTypeBad (* Place holder for errors. *)
```
where `typeVarForm` is defined in STRUCT\_VALS.ML as follow:
```sml
type typeVarForm =
  {
    value: types ref,
    encoding: Word.word
  }
```
When pretty print typeParsetree, it's transformed into `types` type.

# TypeChecking
It seems that typecheck is done when parsing.<br/>
It's hard to lookup the entry point of TYPE\_TREE functor/structure, i only found
some makeParseTypeXXX api being called in PARSE\_DEC.<br/>

The keyword `withtype` appears only in `datatype | abstype`, because in SML,
datatype and type is used different.
So when defining recursive types in datatype, you need to use the keyword
`withtype`. i.e,
```sml
datatype valueMatching =
  ValueMatch of ...
| StructureMatch of { contentsMatch: structureMatch, ... }
| TypeIdMatch of ...
and ...
withtype structureMatch = (int * valueMatching) list
```
STRUCTURES\_.ML depends on STRUCT\_VALS.ML, so you may find some definition in the
latter file. In Overview.html, STRUCTVALSIG.sml appears before lexing/parsing.

## Structure/Signature/Functor, typing
functor/signature can only appear in prog(a.k.a top dec).
While structure can appear in dec or sig-spec.

### Sharing
Sharing is tricky. In STURCUTRES\_.ML
```sml
functor STRUCTURES_ (
...
sharing LEX.Sharing = VALUEOPS.Sharing = ... = PRETTY.Sharing = ... = CODETREE
)  := STRUCTURESSIG =
struct ... end
```
But, LEX.Sharing is
```sml
structure Sharing:
sig
  type pretty = pretty
  and lexan = lexan
  and sys = sys
end
```
while VALUEOPSSIG.sml's Sharing is
```sml
structure Sharing:
sig
  type lexan = lexan
  type codetree = codetree
  type pretty = pretty
  ...
end
```
It doesn't have type sys, and has more types(i.e codetree) than LEX.Sharing, so
what really does `sharing str1 = str2` mean?
sml97-defn explains that. struct sharing is not transitive, which means
sharing A = B
sharing B = C
doesn't mean sharing A = C.
And sharing struct is a composed form, base on type sharing.

### type constraint in struct/sig

```sml
signature T =
sig
  type t
end

structure S: T =
struct
  datatype t = N | S of int
end
```

In structure `datatype t = ...` can fit the spec `type t` in signature. If you
write `type t` instead of `datatype t = ...` in signature, then you are hiding
the constructors.

# Code generation
## codetree
In CodeTree/BaseCodeTreeSig.sml,
```sml
datatype codetree =
  Newenv of codeBinding list * codetree
| Constnt of machineWord * Universal.universal list
| Extract of loadForm
| Indirect of {base: codetree, offset: int, indKind: indKind }
| Eval of (* Evaluate a function with an argument list *)
  {
    function: codetree,
    argList: (codetree * argumentType) list,
    resultType: argumentType
  }
| Unary of {oper: ..., arg1: codetree}
| Binary of {oper: ..., arg1: codetree, arg2: codetree}
| Arbitrary of ...
| Lambda of lambdaForm
| Cond of codetree * codetree * codetree (* If-statement *)
| BeginLoop of ... (* tail-recursive inline function *)
| Loop of (codetree * argumentType) list (* tail-recursive function *)
| Handle of {exp: codetree, handler: codetree, exPacketAddr: int}
| Tuple of {fields: codetree list, isVarient: bool}
| SetContainer of ...
| TagTest of ...
| LoadOperation of ...
| StoreOperation of ...
| BlockOperation of ... (* kind of memmove, memcmp *)
| GetThreadId
| AllocateWordMemory of {numWords: codetree, flags: codetree, initial: codetree}

and loadForm =
  LoadArgument of int
| LoadLocal of int
| LoadClosure of int
| LoadRecursive

withtype lambdaForm =
{
  body: codetree
  isInline: inlineStatus, (* modified by optimiser *)
  name: string,
  closure: loadForm list,
  argTypes: (argumentType * codeUse list) list,
  resultType: argumentType,
  localCount: int,
  recUse: codeUse list
}
```
From parsetree to codetree, some forms is gone, i.e,
```
Ident -> LoadForm
structure -> tuple
functor -> function
signature -> ???
Localdec (* local dec in dec and let dec in exp *) -> Newenv
Applic -> Eval (* local fn is Extract, global fn is Constnt *)
```
The code to handle structure is in STRUCTURES\_.ML.
In
```sml
val (structCode, nLocals) = STRUCTURES.gencodeStructs (parseTree, lex)
```
The struct/functor/signature is gone, the value becomes tuple. Maybe poly will
extend the global env, to bind the structure/functor/signature name to the
value. And the ref name to longid become a Local.

Too many duplicate declarations and definitions, it's hard to find definitions.
So sad. It's said that the duplicate declarations is to make module
self-contained.

The pretty-print functions of codetree is in CodeTree/BaseCodeTree.sml. Some
function name can't grep defn, because the name is composed, i.e:
```sml
| LoadOperation {kind, address } =>
  PrettyBlock (3, false, [],
    [
      PrettyString("Load" ^ BackendIntermediateCode.loadStoreKindRepr kind),
      PrettyBreak (1, 0),
      prettyAddress address
    ]
  )
```


```sml
fun structureCode (str, strName, debugEnv, mkAddr, level):
  { code: codeBinding list, load: codetree } = ...
  FunctorAppl ... => ...
| StructDec {alist, matchToResult=ref matchToResult, ...} =>
  let
    val typeVarMap = TypeVarMap.defaultTypeVarMap(mkAddr, level)
    val (coded, _(*debugEnv*)) = codeStrdecs(strName, alist, ...)
    val loads = List.rev(List.foldl(fn (s, l) => codeLoadStrdecs(s, level) @ l)
  in
    {
      code = typeVarMap.getCachedTypeValues typeVarMap @ coded,
      load = applyMatchActions (mkTuple loads, matchToResult, ...)
    }
  end
```
codeBinding and codetree is defined in codetree.
Next step, read codeStrdecs, codeLoadStrdecs, and applyMatchActions.
codeStrdecs for CoreLang will call gencode in ParseTree/CODEGEN\_PARSETREE.sml.
Why is this function define in ParseTree folder? Whatever, bunch of codeXXX is
in CODEGEN\_PARSETREE.sml.

In CODEGEN\_PARSETREE.sml, `fun name (args, ...) = ...` is translated to `fn
(args, ...) => ... `, the function name is gone, and the type is FunDeclaration
to Fn.

In code generating phase, if we encounter a function, or a case-of expression,
then we will meet match compiler, whose code is in
ParseTree/MATCH\_COMPILER.sml, of about 1000+ lines of code.


### pattern-match
```sml
fun codeMatchPatterns(alt, arg, isHandlerMatch, lineNo, codePatternExpr, ctxt) =
let
  val nPats = length alt
  val andortree = buildTree(alt, ctxt)
  val patternCode as {leafSet, ...} = buildPatternCode(andortree,n Pats, naive)
  fun firePatt 0 = raiseMatchException lineNo
  |   firePatt pattChosn = codePatternExpr (pattChosn - 1)
in
  (codeGenerateMatch(patternCode, arg, firePatt, ctxt), exhaustive)
end
```

```sml
datatype envGeneral =
  EnvGenLoad of loadForm
| EnvGenConst of machineWOrd * Universal.universal list
and envSpecial =
  EnvSpecNone
| EnvSpecTuple of int * (int -> envGeneral * envSpecial)
| EnvSpecInlineFunction of lambdaForm * (int -> envGeneral * envSpecial)
| EnvSpecUnary of Builtins.unaryOps * codetree
| EnvSpecBinary of Builtins.binaryOps * codetree * codetree
```
These datatypes are hard to understand.
```
Env : symbol -> 'a * 'b
where
  'a is load | constant
  'b is tuple | inlinedFunction
```
Env is `symbol -> 'a * 'b`, where `'a` is `load | constant` and

### code optimising
In CodeTree/CODETREE.ML
```sml
fun genCode(pt: codetree, debugSwitches, numLocals) =
let
  fun codeAndPrint(code, nLocal) =
  let
    val () = compilerOut (BASECODETREE.pretty code)
  in
    BACKEND.codeGenerate(code, nLocal, debugSwitches)
  end

  (* optimising *)
  val (numLocals=localCount, general=gen, bindings=decs, special=sepc} =
    OPTIMISER.codetreeOptimiser(pt, debugSwitches, numLocals)
in
  (* spec is special, it comes after optimising *)
  case simplifySpec spec of
    EnvSpecNone =>
    let
      val (code, props) = codeAndPrint (mkEnv(decs, gen), localCount)
    in
      fun () => Constnt(code (), props)
    end
  | simpleSpec =>
    let
      (* ... *)
    in
      fun () => Constnt(generalVal, setInline(mapSpec simpleSpec) generalProps)
    end
end

```
So, the key function here is `OPTIMISER.codetreeOptimiser` and
`BACKEND.codeGenerate`. (What is an envSpecial? Come back later)

Now let's read CODETREE\_OPTIMISER.sml:

### Some examples
ref val
```sml
val x = ref 5;
let
  val Local0 =
    app.(
      TUPLE(fn( Arg0 [] ) LIT1,
            fn( Arg0 [] ) builtin.AllocateWordMemory (LIT1, LIT40, Arg0),
            fn( Arg0 [] ) LoadMLWord [Arg0, LIT0, 0]) [1]
        )
    LIT5;
  val Local1 = Local0;
  val Local2 = Local1;
in
  TUPLE(Local2)
end
```
It seems that the origin output has one extra closing parens. The bug resides in
prettyBuiltin

```sml
datatype vari = A of int | B | C of string
```
I got code explosion here. poly will generate some functions, A, B, C the
tester, with TestTag opcode. And defines some helper functions like eq-vari,
print-vari.


### Generate machine code (codetree -> machineword)
BACKEND is CodetreeCodegenConstantFns. And CodetreeCodegenConstantFns is a
strucuture produce by applying a functor:
```sml
structure CodetreeCodegenConstantFns =
  CODETREE_CODEGEN_CONSTANT_FUNCTIONS (
    strcture BASECODETREE = BaseCodeTree
    and BACKEDN = CodetreeLambdaLift
    and ...
  )
```

### Gen code backend
The following discussion assumes that the current dir is X86Code. Entry point is
X86CodetreeToICode.ML, input is the bicLambdaForm, after lambda lift and static link,
the output is X86ICode. The bic intermediate code is defined in ../BackendIntermeidateCode.sml:
```sml
datatype backendIC =
  BICNewenv of bicCodebinding list * backendIC
| BICConstnt of machineWord * universal list
| ...

type bicLambdaForm =
{
  body: backendIC,
  name: string,
  closure: bicLoadForm list,
  localCount: int,
  ...
}
```
backendIC is like codetree, but adds some new forms:
```sml
datatype backendIC =
| BICField of {base: backendIC, offset: int}
| BICCase of
  {
      cases: backendIC option list
      test: backendIC,
      default: backendIC,
      isExhaustive: bool,
      firstIndex: word
  }
| BICLoadContainer of
  {
      base: backednIC,
      offset: int
  }
```

To print icode vec, you have to call printICodeAbstrct(blockVec, stream), where
blockVec is a vector of blocks, and a block is `(blkno, BasicBlock{block, flow,
...}`, flow is
```sml
datatype flow =
  Unconditional l
| Conditional {cond, trueJ, falseJ, ccRef, ...}
| ExitCode
| SetHandler{handler, continue}
| UncondtionHandle handler
| ConditionHandle{handler, continue}
```
and block is a list of icode.
If you see sth like `LIT <long word data>` in the output of icode, this is printed
by Address.ML, function `stringOfWord`.

### register allocation
Allocate code is in X86AllocateRegisters.ML, if allocate failed, then need to
spill, the spill code is in X86PushRegisters.ML.

It seems that once if you spill a variable to stack, then every later reference will
need a reload first (Reload to which register? In RISC, it seems like split live
range, in CISC, sometimes you can direct access the memory, needn't reload it into a
register to use it).
For example, if r15 is going to be spilled, then
```
r15 = r14 + 8
...
r20 = r15 * 3
r21 = r15 + 20
```
will be rewrite as
```
r15 = r14 + 8
stack[16] = r15
...
r20 = stack[16] * 3
r21 = stack[16] + 20
```
Or, if in RISC,
```
r15 = r14 + 8
store r15, stack[16]
...
ld r20', stack[16]
r20 = r20' * 3
ld r21', stack[16]
r21 = r21' + 20
```
Here we have two `ld r20', stack[16]`, it can be optimize and elimited, by using
cache or other optimizing techniques.
In X86PushRegisters.ML, it uses `pregMap` to remember r15 (to remember such
info: is it in a real reg, or on the stack?)

#### identify register references

##### pass1: find decs/refs
scanCode, handling one instruction
```sml
fun scanCode(instr, original as {code, decs, refs, loopRegs, ...}) =
let
  val { sources, dests, ... } = getInstructionState instr
  val sourceRegNos = map regNo sources
in
  let
    val () = List.app incrRef sourceRegNos
  in
    {
      { code = instr :: code,
        decs = union(listToSet destRegNos, decs),
        refs = union(listToSet sourceRegNos, refs), ...
    }
  end
end
```
blockScan, scans a block, aka a list of instructions, use depth first search to
process successors first
```sml
fun blockScan blockNo =
if has processed then ()
else
let
  mark block as processed
  val thisBlock = Vector.sub(blockVector, blockNo)
  val successors = blockSuccors thisBlock
  val _ = List.app blockScan successors (* depth first search, to update
  refcount *)
  fun scanCode(instr, original) = #= ref scanCode =#
in
  val { code, decs, refs, loopRegs, ... } =
    List.foldr scanCode
      { code=[], decs=emptySet, refs=emptySet, loopRegs=emptySet} block
end
```
Then, update declare/import/resultCode/localLoopRegArray etc
```
declare = decs
import := minus(refs, decs)
```

##### pass2:

pass1 is processing individual blocks, while pass2 is processing between blocks,
so there are passThroughes/imports/exports registers.

##### pass3:

pass3 will changed some instruction, remove some elimitable instruction if the
dest reg is not referenced afterwards. And it will set the field `saveRegs` for some
instruction (for example, function call instruction, and allocate memory
instruction).

#### X86AllocateRegister

The algorithm:
1. Use an array to record the allocate result, so if one is allocated, then just
   use it.
2. If there is a preferred register, then try it(if failed, return fail, and
   append the conflict registers to spill). In some instruction, preferred reg
   is the realReg in instruction(Still very confusing).

3. Try real hint register.
   For example, for BlockMove
   instruction, esi, edi, ecx are hint registers

```
v1_reg <- esi
v2_reg <- edi
len_reg <- ecx
```

	There is a big switch to handle hint register for spec
	instructions.

4. Try if there is a "friend"(???).
5. Try general registers.

### ICode translate to X86Code

`fun moveMultipleValues` in line 291 seems to be an important function.
`val newCode = codeCreate (functionName, profileObject, debugSwitches)` in line
1654.
codeCreate is defined in X86OUTPUTCODE.ML. And there is a X86FOREIGNCALL.sml.

Note:
- In polyml, the author likes to use array as a map(index as key). It works
though.
- Some indent didnt feel right, e.g

```sml
fun foo [] = ...
|   foo (x::rest) = ...
```

I prefer it to be

```sml
fun foo [] = ...
  | foo (x::rest) = ...
```

So that vim can do the folding by indent better. (And better anylyze by human
eys.) The case's indent is similar.
In if-then-else, with let-in statement, should we ident the let-in part?

# The big picture

The overview doc says, there are 4 major passes:
- parsing
- type-checking
- code-generation
- optimise & transform to machine code

In STRUCTURES\_.ML, you will see there is some comment like `Code-generation
phase`, `Second pass`. So this is the clue to follow and findout TypeChecking.
Or, by reading COMPILER\_BODY.ML, the flow is as follow:
```sml
  val parseTree: STRUCTURES.program =
      PARSEDEC.parseDec (...)
  let
      (* pass 2, match ident and declares *)
      val () = STRUCTURES.pass2Structs (parseTree, lex, Env globals)
  in
      let
          (* pass 3, code generation *)
          val (structCode, nLocals) = STRUCTURES.gencodeStructs(parseTree, lex)
      in
          (* pass 4 *)
          let
              val resultCode = CODETREE.genCode(structCode, debugSwitches,
              nLocals)
              fun executeCode() = STRUCTURES.pass4Structs (resultCode (),
              parseTree)
          in
              (SOME(...), SOME executeCode)
          end
      end
  end
```

# Startup
I get the information by greping. That's not convinietn, but i dont<br/>
have a better parsing tools.
```
main - libpolymain/polystub.c
  polymain  - libpolyml/mpoly.cpp
    InitModules
    CreateHeap()
    rootFunction = InitHeaderFromExport(exports)
    StartModules
    processes->BeginRootThread(rootFunction)
    finish(0)
```
where
```
// _exportDescription* -> PolyObject
InitHeaderFromExport - libpolyml/savestate.cpp
```
Actually, rootFunction is in `basis/TopLevelPolyML.sml`.
```
$ grep -r rootFunction *
basis/build.sml:val () = Bootstrap.use "basis/TopLevelPolyML.sml" (* Add
rootFunction to Poly/ML *)
basis/TopLevelPolyML.sml: fun rootFunction () : unit = ...
```
The `rootFunction`, depends on arguments, may call compiler to handle <br/>
`--script <filename>`, or call `shell()` to enter REPL mode.<br/>
And, `PolyML.compiler` has different phases, the first one is in<br/>
`mlsource/MLCompiler/COMPILER_BODY.ML`.<br/>
and the last one, is redefined in `basis/FinalPolyML.sml as follow:
```
fun polyCompiler (getChar: unit -> char option, parameters: compilerParameters list) = ...
...
structure PolyML =
struct
  open PolyML
  val compiler = polyCompiler
  ...
end
```


# Reading progress
17/2/2019

I have read `PARSE_DEC.ML`, mark it. I will come back to figure out some<br/>
details. The structure: <br/>
```
ml_bind
  Boot
    Address
    HashTable
    ...
  MLCompiler
    Make
      Lex
      CompilerBody
        Lex
        SymSet
        ParseDec
      Debug
      Pretty
      UniversalTable
      StructVals
```

19/2/2019

The reading progress is slowing down. That's OK, i think. Besides reading
the code, i'm also reading some books(i.e "Engineering a compiler"). And in the
near future, i may write some test code, which will take more time, which will
even slow down more. So take it easy! After all, reading is not everything. Even
if i've done reading all the source code, that won't mean that i'm in a new
  stage. I still have to write many code to learn how to program, how to write a
  compiler.

07/03/2019

The extendedBasicBlock and register allocation stuff is in CodeTree/X86Code.

17/03/2019

Sometimes a file is too big(~1000 loc or more), i want to see a brief
fun/type/value declaration, but the editor can't support it well enough. So i
want to modify the code, remember the files along with those definition
informations, and then offer a function to print the info out by file name.

23/04/2019

I've been reading X86Code for quite a long time. When i try to rewrite some
snippets in python, i found that python is usually more concise than sml. The
cons of python is bad type inference/annotation, and lack pattern matching.
I've read identified regsiter, and X86ICodeGetConflictSets.ML.
What does GetConflictSets do? 
- It reserve some specific register for some
special instruction. For example, `BlockMove{srcAddr, destAddr, length, ...}`,
need to reserve `esi` for `srcAddr`, `edi` for `destAddr`, and `ecx` for
`length`. 
- Some instruction's dest reg may conflict with its source registers, mark them
  and add conflicts between them.


# Q&A
Q: How to print pass info, how to print parsetree after pass etc?<br/>
A:<br/>
After reading `PolyMLCompiler.html`, and i found there is some flags:<br/>
```sml
val parsetree: bool ref
val codetree: bool ref
val codetreeAfterOpt: bool ref
val icode: bool ref
val assemblyCode: bool ref
val pstackTrace: bool ref
```
So, if i want to check the parsetree, just set it to true:
```sml
PolyML.Compiler.parsetree := true
```
Q: How to do optional arg in SML?<br/>
A:<br/>

Q: There is no Set in polyml, how to do set-related algorithms in sml? And how
to manage libraries in polyml?<br/>
A: There is a IntSet structure in CodeTree/X86Code/IntSet.sml.

Q: When does the pattern-match form get compiled into if-else?<br/>
A:<br/>

Q: How does polyml do pretty-print?<br/>
A: i.e, codetree's pretty printing is done in BaseCodeTree.sml.

Q: Is there any way to iter over a tuple?
A: Maybe you should instead use list if you have such need.

Q: It's said that SML's polymorphic only applies to value, but not function etc.
Type inference has some restrictions. why? And it's said that it has some
connection with ref type.
A:

Q: I want to add some printting in ParseTree/CODEGEN\_PARSETREE.sml, but it will
raise Io exception. Why is that, and how can i add debug printting stmts?
A: 

Q: How to include library path?
A: In polyml, it seems you can only use file to include library.


Q: What is SetContainer in codetree? When does it introduce to world?
A: SetContainer is used for functions that return tuples. It's introduce in
parsetree codegeneration.


# Doubts
- functors definition:
```sml
type functors =
  Functor of
  {
    name: string,
    arg:  structVals,
    result: signatures,
    access: valAccess,
    locations: locationProp list
  }
```
Why result's type is signatures, but not structVals?

- types definite
```sml
datatype types =
  TypeVar of typeVarForm
| TypeConstruction of
  {
    name: string,
    constr: typeConstrs,
    args: type list,
    locations: ...
  }
| FunctionType of
  {
    arg:  types,
    result: types,
  }
| LabelledType of labelledRec
| OverloadSet of
  {
    typeset: typeConstrs list
  }
| BadTypes
| EmptyType

type labelledRec =
  {
      recList: {name: string, typeof: types } list,
      fullList: labelFieldList
  }
```
What is OverloadSet?
There is not explicit syntax form. In INITIALISE\_.ML, we found that operators
such as +, - are Overloaded. I think it's kind of polymorphic.

- shadow structure/functor
There is some code like
```sml
structure PolyML =
struct
  open PolyML
  ...
end
```
I think the origin `PolyML` module is shadowed afterwards, that's a little
confusing, and it makes searching for definition harder. Because, when you see
an identifier like `PolyML.compiler`, you may wonder which `PolyML`, the init
one or the final one? Do you have to trace down to find out?
I read the blog [Go & Versioning, Part 9](https://research.swtch.com/vgo-eng),
they use url in importing, for example, `import "github.com/pborman/uuid"`, this
can resolve the `which package` problem.
__NOTE__: previously, i misunderstood `open` and `include`, i thought that open
will not export the ids and types as member of current structure, but it does.
`open` is for structure, while `include` is for signature, they are similar.

