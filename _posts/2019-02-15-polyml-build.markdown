---
layout: post
title:  "Poly build instructions"
date:   2019-02-15 01:37:50 +0800
categories: jekyll update
---
According to official site's instruction, you have to run<br/>
the following instructions:
```bash
make
make compiler
```

What it really does, is:
```bash
# build polyimport from C source ...
gcc 
# to build basis lib etc
./polyimport polytemp.txt . < ./exportPoly.sml
# to build compiler
./poly --error-exit < mlsource/BuildExport.sml
# the above step will regenerate polytemp.txt, so run polyimport again
./polyimport  polytemp.txt -I . < ./exportPoly.sml
# generate poly
gcc -O3 -o poly plyexport.o libpolyxxx ...
```
polytemp.txt is generated by mlsource/BuildExport.sml, it's the portable object
file which contains the code of compiler and other stuff.
## What does exportPoly.sml do?
```sml
(* build the main basis library *)
Bootstrap.use "basis/build.sml"
PolyML.shareCommonData PolyML.rootFunction;
(* here fileName defaults to `polyexport' *)
PolyML.export(fileName, PolyML.rootFunction)
```
shareCommonData is used for reducing the image size.
The `documentation/Reference/PolyMLStructure.html#export` part has some nice
doc, saying that export will dump the rootFunction into an object file, which
is linked to build poly later.

export/exportPortable is defined in basis/InitialPolyML.ML:
```sml
val callExport: string * (unit->unit) -> unit = RunCall.rtsCallFull2
"PolyExport"
val callExportP: string * (unit->unit) -> unit = RunCall.rtsCallFull2
"PolyExportPortable"
fun export(filename, f) = callExport(filename, runFunction f)
and exportPortable(filename, f) = callExportP(filename, runFunction f)
```
I don't known what exactly happened, but, this 2 functions, is a wrapper of the
C function PolyExport and PolyExportPortable. They will append `.o`, and `.txt`
suffix to the filename. So polyimport.txt is the portable file of rootFunction,
while polyexport.o is the native file of rootFunction.
Having that idea, so polyc is just a script, which will call
PolyML.export(fileName, main) to generate the object file, then link it into an
executable binprogram.

But running nm shows that the symbol table is incomplete, but use strings to
show, there are some hidden symbols.

# Lexing
I should read `LEX_.ML`. The most important type is:
```sml
type lexan =
  {
    stream: uint -> char option,  (* get char *)
    ch: char ref,
    sy: sys ref,  (* AndSy, DatatypeSy, etc ... *)
    id: string ref,
    pushedSym: sys ref, (* to push back lookahead sy ... *)
    (* ... more fields omitted *)
  }
```
For example, `insymbol` will eat the next input symbol
```sml
fun insymbol (state as {sy, pushedSym, ...}:lexan) =
  if ! pushedSym <> OtherSy
  then
    pushedSym := OtherSy
  else
  (
    sy := OtherSy
    parseToken state
  )
```
In the firs case, `pushedSym` is not empty, which means that<br/>
there is a push back before. So we reset it, so we eat the symbol.<br/>
Otherwise, we call `parseToken` to get a new sym from the token stream.

# Parsing

# TypeChecking
It seems that typecheck is done when parsing.<br/>
It's hard to lookup the entry point of TYPE_TREE functor/structure, i only found
some makeParseTypeXXX api being called in PARSE_DEC.<br/>

The keyword `withtype` appears only in `datatype | abstype`, because in SML,
datatype and type is used different.
So when defining recursive types in datatype, you need to use the keyword
`withtype`. i.e,
```sml
datatype valueMatching =
  ValueMatch of ...
| StructureMatch of { contentsMatch: structureMatch, ... }
| TypeIdMatch of ...
and ...
withtype structureMatch = (int * valueMatching) list
```
STRUCTURES_.ML depends on STRUCT_VALS.ML, so you may find some definition in the
latter file. In Overview.html, STRUCTVALSIG.sml appears before lexing/parsing.

## Structure/Signature/Functor, typing
functor/signature can only appear in prog(aka top dec).
While structure can appear in dec or sig-spec.

### Sharing
Sharing is tricky. In STURCUTRES_.ML
```sml
functor STRUCTURES_ (
...
sharing LEX.Sharing = VALUEOPS.Sharing = ... = PRETTY.Sharing = ... = CODETREE
)  := STRUCTURESSIG =
struct ... end
```
But, LEX.Sharing is
```sml
structure Sharing:
sig
  type pretty = pretty
  and lexan = lexan
  and sys = sys
end
```
while VALUEOPSSIG.sml's Sharing is
```sml
structure Sharing:
sig
  type lexan = lexan
  type codetree = codetree
  type pretty = pretty
  ...
end
```
It doesn't have type sys, and has more types(i.e codetree) than LEX.Sharing, so
what really does `sharing str1 = str2` mean?
sml97-defn explains that. struct sharing is not transitive, which means
sharing A = B
sharing B = C
doesn't mean sharing A = C.
And sharing struct is a composed form, base on type sharing.

# Code generation
## codetree
In CodeTree/BaseCodeTreeSig.sml,
```sml
datatype codetree =
  Newenv of codeBinding list * codetree
| Constnt of macnineWord * Universal.universal list
| Extract of loadForm
| Indirect of {base: codetree, offset: int, indKind: indKind }
| Eval of (* Evaluate a function with an argument list *)
  {
    function: codetree,
    argList: (codetree * argumentType) list,
    resultType: argumentType
  }
| Unary of {oper: ..., arg1: codetree}
| Binary of {oper: ..., arg1: codetree, arg2: codetree}
| Arbitrary of ...
| Lambda of lambdaForm
| Cond of codetree * codetree * codetree (* If-statement *)
| BeginLoop of ... (* tail-recursive inline function *)
| Loop of (codetree * argumentType) list (* tail-recursive function *)
| Handle of {exp: codetree, handler: codetree, exPacketAddr: int}
| Tuple of {fields: codetree list, isVarient: bool}
| SetContainer of ...
| TagTest of ...
| LoadOperation of ...
| StoreOperation of ...
| BlockOperation of ...
| GetThreadId
| AllocateWordMemory of {numWords: codetree, flags: codetree, initial: codetree}

and loadForm =
  LoadArgument of int
| LoadLocal of int
| LoadClosure of int
| LoadRecursive

and lambdaForm =
{
  body: codetree
  isInline: inlineStatus, (* modified by optimiser *)
  name: string,
  closure: loadForm list,
  argTypes: (argumentType * codeUse list) list,
  resultType: argumentType,
  localCount: int,
  recUse: codeUse list
}
```
From parsetree to codetree, some forms is gone, i.e,<br/>
```
Ident -> LoadForm
structure/signature/functor -> ???
Localdec (* local dec in dec and let dec in exp *) -> Newenv
```
struct is repr as tuple.
The code to handle structure is in STRUCTURES_.ML.
In
```sml
val (structCode, nLocals) = STRUCTURES.gencodeStructs (parseTree, lex)
```
The struct/functor/signature is gone, the value becomes tuple. Maybe poly will
extend the global env, to bind the structure/functor/signature name to the
value. And the ref name to longid become a Local.

Too many duplicate declarations and definitions, it's hard to find definitions.
So sad. It's said that the duplicate declarations is to make module
self-contained.

The pretty-print functions of codetree is in CodeTree/BaseCodeTree.sml. Some
function name can't grep defn, because the name is composed, i.e:
```sml
| LoadOperation {kind, address } =>
  PrettyBlock (3, false, [],
    [
      PrettyString("Load" ^ BackendIntermediateCode.loadStoreKindRepr kind),
      PrettyBreak (1, 0),
      prettyAddress address
    ]
  )
```

```sml
fun structureCode (str, strName, debugEnv, mkAddr, level):
  { code: codeBinding list, load: codetree } = ...
  FunctorAppl ... => ...
| StructDec {alist, matchToResult=ref matchToResult, ...} =>
  let
    val typeVarMap = TypeVarMap.defaultTypeVarMap(mkAddr, level)
    val (coded, _(*debugEnv*)) = codeStrdecs(strName, alist, ...)
    val loads = List.rev(List.foldl(fn (s, l) => codeLoadStrdecs(s, level) @ l)
  in
    {
      code = typeVarMap.getCachedTypeValues typeVarMap @ coded,
      load = applyMatchActions (mkTuple loads, matchToResult, ...)
    }
  end
```
codeBinding and codetree is defined in codetree.
Next step, read codeStrdecs, codeLoadStrdecs, and applyMatchActions.
codeStrdecs for CoreLang will call gencode in ParseTree/CODEGEN_PARSETREE.sml.
Why is this function define in ParseTree folder? Whatever, bunch of codeXXX is
in CODEGEN_PARSETREE.sml.

# The big picture

The overview doc says, there are 4 major passes:
- parsing
- type-checking
- code-generation
- optimise & transform to machine code

In STRUCTURES_.ML, you will see there is some comment like `Code-generation
phase`, `Second pass`. So this is the clue to follow and findout TypeChecking.
Or, by reading COMPILER_BODY.ML, the flow is as follow:
```sml
  val parseTree: STRUCTURES.program =
      PARSEDEC.parseDec (...)
  let
      (* pass 2, match ident and declares *)
      val () = STRUCTURES.pass2Structs (parseTree, lex, Env globals)
  in
      let
          (* pass 3, code generation *)
          val (structCode, nLocals) = STRUCTURES.gencodeStructs(parseTree, lex)
      in
          (* pass 4 *)
          let
              val resultCode = CODETREE.genCode(structCode, debugSwitches,
              nLocals)
              fun executeCode() = STRUCTURES.pass4Structs (resultCode (),
              parseTree)
          in
              (SOME(...), SOME executeCode)
          end
      end
  end
```

# Startup
I get the information by greping. That's not convinietn, but i dont<br/>
have a better parsing tools.
```
main - libpolymain/polystub.c
  polymain  - libpolyml/mpoly.cpp
    InitModules
    CreateHeap()
    rootFunction = InitHeaderFromExport(exports)
    StartModules
    processes->BeginRootThread(rootFunction)
    finish(0)
```
where
```
// _exportDescription* -> PolyObject
InitHeaderFromExport - libpolyml/savestate.cpp
```
Actually, rootFunction is in `basis/TopLevelPolyML.sml`.
```
$ grep -r rootFunction *
basis/build.sml:val () = Bootstrap.use "basis/TopLevelPolyML.sml" (* Add
rootFunction to Poly/ML *)
basis/TopLevelPolyML.sml: fun rootFunction () : unit = ...
```
The `rootFunction`, depends on arguments, may call compiler to handle <br/>
`--script <filename>`, or call `shell()` to enter REPL mode.<br/>
And, `PolyML.compiler` has different phases, the first one is in<br/>
`mlsource/MLCompiler/COMPILER_BODY.ML`.<br/>
and the last one, is redefined in `basis/FinalPolyML.sml as follow:
```
fun polyCompiler (getChar: unit -> char option, parameters: compilerParameters list) = ...
...
structure PolyML =
struct
  open PolyML
  val compiler = polyCompiler
  ...
end
```


# Reading progress
17/2/2018

I have read `PARSE_DEC.ML`, mark it. I will come back to figure out some<br/>
details. The structure: <br/>
```
ml_bind
  Boot
    Address
    HashTable
    ...
  MLCompiler
    Make
      Lex
      CompilerBody
        Lex
        SymSet
        ParseDec
      Debug
      Pretty
      UniversalTable
      StructVals
```

19/2/2018

The reading progress is slowing down. That's OK, i think. Besides reading
the code, i'm also reading some books(i.e "Engineering a compiler"). And in the
near future, i may write some test code, which will take more time, which will
even slow down more. So take it easy! After all, reading is not everything. Even
if i've done reading all the source code, that won't mean that i'm in a new
  stage. I still have to write many code to learn how to program, how to write a
  compiler.

# Q&A
Q: How to print pass info, how to print parsetree after pass etc?<br/>
A:<br/>
After reading `PolyMLCompiler.html`, and i found there is some flags:<br/>
```sml
val parsetree: bool ref
val codetree: bool ref
val codetreeAfterOpt: bool ref
val assemblyCode: bool ref
val pstackTrace: bool ref
```
So, if i want to check the parsetree, just set it to true:
```sml
PolyML.Compiler.parsetree := true
```
Q: How to do optional arg in SML?<br/>
A:<br/>

Q: There is no Set in polyml, how to do set-related algorithms in sml? And how
to manage libraries in polyml?<br/>
A: There is a IntSet structure in CodeTree/X86Code/IntSet.sml.

Q: When does the pattern-match form get compiled into if-else?<br/>
A:<br/>

Q: How does polyml do pretty-print?<br/>
A: i.e, codetree's pretty printing is done in BaseCodeTree.sml.

Q: Is there any way to iter over a tuple?
A: Maybe you should instead use list if you have such need.

Q: It's said that SML's polymorphic only applies to value, but not function etc.
Type inference has some restrictions. why? And it's said that it has some
connection with ref type.
A:


# Doubts
- functors definition:
```sml
type functors =
  Functor of
  {
    name: string,
    arg:  structVals,
    result: signatures,
    access: valAccess,
    locations: locationProp list
  }
```
Whye result's type is signatures, but not structVals?

- types definite
```sml
type types =
  TypeVar of typeVarForm
| TypeConstruction of
  {
    name: string,
    constr: typeConstrs,
    args: type list,
    locations: ...
  }
| FunctionType of
  {
    arg:  types,
    result: types,
  }
| LabelledType of labelledRec
| OverloadSet of
  {
    typeset: typeConstrs list
  }
| BadTypes
| EmptyType
```
What is OverloadSet?
There is not explicit syntax form. In INITIALISE_.ML, we found that operators
such as +, - are Overloaded. I think it's kind of polymorphic.
