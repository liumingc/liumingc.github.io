I was reading xavier's [zam vm paper](https://xavierleroy.org/talks/zam-kazam05.pdf), i found the transition description is clean, so i'll follow similar notation.

## stack related instructions

| code        | env  | stack     | regs   | code' | env' | stack'    | regs'     |
| ----------- | ---- | --------- | ------ | ----- | ---- | --------- | --------- |
| push;c      | e    | s         | accu=a | c     | e    | a.s       |           |
| push1;c     | e    | v.s       | accu=a | c     | e    | a.v.s     | accu=v    |
| push2;c     | e    | v1.v2.s   | accu=a | c     | e    | a.v1.v2.s | accu=v2   |
| access(n);c | e    | v1...vn.s | accu=a | c     | e    | v1...vn.s | accu=vn   |
| pop(n);c    | e    | v1...vn.s | accu=a | c     | e    | s         |           |
| assign(n);c | e    | v1...vn.s | accu=a | c     | e    | v1...a.s  | accu=UNIT |

## env access

| code            | env  | stack | regs   | code' | env' | stack' | regs'     |
| --------------- | ---- | ----- | ------ | ----- | ---- | ------ | --------- |
| pushenvacc(n);c | e    | s     | accu=a | c     | e    | a.s    | accu=e(n) |
| envacc(n); c    | e    | s     | accu=a | c     | e    | s      | accu=e(n) |

## function application

Function application is much more complicated, it seems the previous way is not ok to present the transition. So, i decided to change the table structure,

The first line is the old state, the next line is the next state

`PUSH_RETADDR`

| code           | stack    | env  | accu | extra_args |
| -------------- | -------- | ---- | ---- | ---------- |
| push_retaddr;c | s        | e    | a    | n          |
| c              | pc.e.n.s | e    | a    | n          |

`APPLY`

| code        | stack | env  | accu | extra_args |
| ----------- | ----- | ---- | ---- | ---------- |
| apply(n');c | s     | e    | a    | n          |
| a(0)        | s     | a    | a    | n'         |

PS: will check stack, so maybe there is a realloc of stack when `APPLY`.

There is a group of `APPLY` instructions.

`APPLY<n>`

| code          | stack                                    | env  | accu | extra_args |
| ------------- | ---------------------------------------- | ---- | ---- | ---------- |
| `apply<n>`; c | a<sub>1</sub>.a<sub>2</sub>...a<sub>n</sub>.s | e    | a    | n          |
| a(0)          | a<sub>1</sub>.a<sub>2</sub>...a<sub>n</sub>.pc.e.n.s | a    | a    | `<n>-1`    |

`<n>` is 1 .. 4.

`APPTERM`

I don't know when will generate the `APPTERM` instruction.

Whatever, here is the transition.

Code sequence:

```
APPTERM; NARGS; SLOTSIZE; C
```

`NARGS` is one byte constant, `SLOTSIZE` is 2-byte constant.

Let's assume that `NARKGS=k`, `SLOTSIZE=q`,

| code            | stack                                    | env  | accu | extra_args |
| --------------- | ---------------------------------------- | ---- | ---- | ---------- |
| appterm; k; q;c | a<sub>1</sub>...a<sub>k</sub>...a<sub>q</sub>.s | e    | a    | n          |
| c               | a<sub>1</sub>...a<sub>k</sub>.s          | e    | a    | n+k        |

OK, the above transition is not done, because there is a `goto appterm` in the source code,

what `appterm:` does is as follow:

| code       | stack | env  | accu | extra_args |
| ---------- | ----- | ---- | ---- | ---------- |
| appterm; c | s     | e    | a    | n          |
| a(0)       | s     | a    | a    | n          |

There is no `pc.e.n` sequence on the stack, so that's something like tailcall, i think.

`APPTERM<n>`

OK, the `NARGS=k` is removed from the codestream, `NARGS=<n>` now. So that's what `APPTERM<n>` does.

`RETURN<k>`

| code      | stack                                    | env  | accu | extra_args |           |
| --------- | ---------------------------------------- | ---- | ---- | ---------- | --------- |
| return1;c | v<sub>1</sub>...v<sub>k</sub>.pc.e'.n'.s | e    | a    | n          |           |
| a(0)      | s                                        | a    | a    | n-1        | if n > 0  |
| pc        | s                                        | e'   | a    | n'         | if n == 0 |

If the instruction is `RETURN`, not `RETURN1` or `RETURN2` etc, then the k is taken from the code stream, a 2-byte k.

`RESTART`

| code      | stack                           | env                                  | accu | extra_args |
| --------- | ------------------------------- | ------------------------------------ | ---- | ---------- |
| restart;c | s                               | v.e'.a<sub>1</sub>...a<sub>k</sub>.e | a    | n          |
| c         | a<sub>1</sub>...a<sub>k</sub>.s | e'                                   | a    | n+k        |

k is `Wosize_val(env) - 2`, seems wired, defer to figure it out later.

`GRAB`

| code       | stack                                    | env  | accu      | extra_args |           |
| ---------- | ---------------------------------------- | ---- | --------- | ---------- | --------- |
| grab; k; c | s as a<sub>0</sub>a<sub>1</sub>...a<sub>n</sub>.pc.e'.n'.s' | e    | a         | n          |           |
| c          | s                                        | e    | a         | n-k        | if n >= k |
| pc         | s'                                       | e'   | Clos(...) | n'         | if m < k  |

Note: k is the required argument number. if `n < k`, then we need to build a closure, `Clos(n+1, pc=[restart; grab; k; c])`.

There is always a `RESTART` before `GRAB; k`. So the Clos's pc just pointed to `curr_pc - 3`.

`CLOSURE`

`CLOSREC`



